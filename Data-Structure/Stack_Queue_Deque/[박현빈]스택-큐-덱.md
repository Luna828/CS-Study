# 목차 
[1. 프로그램 성능평가](#1-프로그램-성능평가) <br>
[1-1. 점근적 표기법](#1-1-점근적-표기법-asymptotic-notation) <br>
[2. 시간 복잡도](#2-시간-복잡도-time-complexity) <br>
[2-1. 빅 오 함수의 종류](#2-1-시간복잡도-빅-오-표기법-함수의-종류) <br>
[3. 공간 복잡도](#3-공간-복잡도-space-complexity) <br>

# 1. 프로그램 성능평가
개발된 프로그램을 평가하는 작업을 성능평가(performance evaluation)이라고 한다. 정량적으로 프로그램의 성능을 평가할 수 있는 기준으로는 대표적으로 시간복잡도와 공간복잡도가 있다. 

이름에서 알 수 있듯, 공간 복잡도는 메모리 양(memory space)를 의미하고, 시간 복잡도는 프로그램 수행을 완료하는데 걸리는 시간(computation time)을 말한다.

## 1-1. 점근적 표기법 (asymptotic notation)

점근적 표기법이란 입력의 수가 증가할 때 알고리즘의 시간 복잡도 및 공간 복잡도의 변화 패턴을 표현하는 방법이다. 알고리즘 성능에 영향을 크게 미치는 부분만을 표시하는 것이 특징이다.

1. 빅 오 (최악의 경우)

n(0) 이상인 모든 n에 대하여 시간 복잡도 함수 f(n) ≤ c*g(n) 를 만족하는 양의 상수 c의 n(0)가 존재한다면, f(n) = O(g(n))이라고 표시할 수 있다.

의미) n(0)보다 큰 모든 n에 대해서 f(n)의 수행 시간은 상한선 c*g(n)을 넘지 않는다.

2. 빅 오메가 (최상의 경우)

n(0) 이상인 모든 n에 대하여 시간 복잡도 함수 f(n) ≥ c*g(n) 를 만족하는 양의 상수 c의 n(0)가 존재한다면, f(n) = Ω(g(n))이라고 표시할 수 있다. 

의미) n(0)보다 큰 모든 n에 대해서 f(n)의 수행 시간은 하한선 c*g(n)보다 항상 많이 걸린다. 

3. 빅 세타 (평균의 경우)

n(0) 이상인 모든 n에 대하여 시간 복잡도 함수 c(1)*g(n) ≤ (n) ≤ c(2)*g(n) 를 만족하는 양의 상수 c의 n(0)가 존재한다면, f(n)=Θ(g(n))이라고 표시할 수 있다. 

의미) n(0)보다 큰 모든 n에 대해서 f(n)의 수행 시간은 하한선(c1*g(n))과 상한선 (c(2)*g(n)) 범위 사이에 존재한다. 

***이러한 점금적 표기법은 후에 나올 시간 복잡도에서 굉장히 중요하게 다뤄지니 잘 알아두자.***

# 2. 시간 복잡도 (Time Complexity)

시간 복잡도는 프로그램 실행을 완료하는데 필요한 식나으로 컴파일 시간과 실행 시간으로 구분한다. 컴파일 시간은 예측 가능한 고성 시간이지만, 실행 시간은 가변적이기 떄문에 시간 복잡도 평가에서 더 중요하다. 시간 복잡도 계산을 위해 프로그램의 물리적인 실행 시간을 측정하는 방법은 환경에 따라 매번 달라지는 문제가 발생한다. 따라서 실제 실행 시간 보다는 실행하는 명령문의 수를 세어 시간 복잡도로 사용한다. 

예를 들어보자. 주석의 숫자는 순서대로 명령문 수, 빈도 수, 총 횟수이다. 

```swift
func factorial(n: Int) -> Int { // 0 0 0 
    if n > 0 {  // 1 n+1 n+1
        return n * factorial(n-1)   // 1 n n
    }
    return 1    // 1 1 1 
}
// 총 2n+2
```

요렇다는걸 알 수 있다. 그런데 우리한테 중요한건 뭐다? 그래프를 그릴때 가장 중요한 최고차항만 남겨두고 싹 다 쳐내는 것. 따라서 위의 코드는 O(n)의 시간 복잡도를 가진다고 할 수 있다. 간단한 예시를 한 번 더 들어보자. 

```swift
func twiceFor(n: Int) -> Int {
    var result = 0
    for i in 0..<n {
        for j in 0..<n {
            result = i + j
        }
    }
    return result 
}
```

이러한 코드가 있다고 하자. 그렇다면 지금 n번 반복이 2번 일어나니, O(n^2)의 시간복잡도를 가지는 것을 알 수 있다. 

## 2-1. 시간복잡도 빅-오 표기법 함수의 종류 

![image](https://github.com/hdaisywd/CS-Study/assets/102342953/587581b5-99a6-4bce-bd03-07c1c8fa4bcf)

이 사진은 시간 복잡도의 종류 별 수행 속도의 좋고 나쁨을 상대적으로 순위 매긴 표이다. 와닿지 않는다면 아래를 보자. 

![image](https://github.com/hdaisywd/CS-Study/assets/102342953/55588c6b-a1f8-47da-8b33-7967b94076dd)

위의 사진을 보면, 반복 횟수가 늘어날수록 해야하는 수행 시간이 아래로 갈 수록 기하급수적으로 늘어나는 것을 확인할 수 있다. 이처럼 시간복잡도를 고려하지 않고 코드를 짠다면, 대형참사가 일어날 수도 있다. 좀 더 가시적으로 확인하기 쉽게 그래프를 봐보자. 

![image](https://github.com/hdaisywd/CS-Study/assets/102342953/f7aa1291-3b1e-49f3-9dd4-9f6b60a2fc01)

갈수록 기울기가 낮아지는 그래프와 다르게 n^n 함수는 엄청나게 빠른 속도로 증가하는 것을 확인할 수 있다. 따라서 코드를 작성한 후 시간 복잡도를 알아내, 수행 시간이 지나치게 길어지는 코드면 시간 복잡도를 줄이기 위해 노력하는 수고를 할 필요가 있다. 

우리가 직접 짜는 코드도 그렇지만, swift (타 언어도 마찬가지!)의 내장 함수, 메소드들도 시간복잡도를 가진다. 이를 잘 고려해서 알고리즘을 짜야하는데, 한 번 스위프트의 각 메소드, 함수 별 시간복잡도를 알아보자. 

[참고 블로그](https://demian-develop.tistory.com/30)

# 3. 공간 복잡도 (Space Complexity)

공간 복잡도는 알고리즘 실행에 필요한 메모리 양(memory space)을 정의한다. 메모리 공간은 두 가지가 존재한다. 

1. 고정 요구 공간(fixed memory space)
프로그램 실행 시작부터 끝까지 메모리 크기의 변화가 없는 공간을 뜻한다. ex) 프로그램 명령어, 고정 크기 변수, 상수 등
2. 가변 요구 공간(variable memory space)
프로그램 실행 중에 요청되어 크기를 예측하기 어려운 경우에 해당한다. 고정 요구 공간은 가변이므로 공간 복잡도는 가변 요구 공간에 의해 결정 된다. ex) 함수에 배열 전달 또는 재귀 호출 등의 요소가 포함되는 경우 등

예시를 들어보겠다. 

```swift
func addNum(a: Int, b: Int) -> Int {
    return a + b
}
```

위의 코드는 컴파일 이후로 변경되지 않는 고정 공간 변수만 사용하고 있다. 따라서 가변 요구 공간은 0이다. 즉, 고정 요구 공간만 필요하므로 공간 복잡도는 O(1)이라고 할 수 있다. 

```swift
func factorial(n: Int) -> Int {
    if n > 0 {
        return n * factorial(n-1)
    }
    return 1
}
```

위의 코드는 재귀 호출을 통해 팩토리얼 계산을 수행한다. 함수는 호출 시마다 매개 변수, 지역변수, 회귀 주소(return address)를 저장해야 한다. 따라서 재귀 호출 횟수에 비례하여 가변 공간이 증가한다. 위 코드의 공간 복잡도를 간단히 변수 n을 기준으로 생각하면, n 부터 1까지 n이 호출되므로 공간복잡도는 O(n)이다.