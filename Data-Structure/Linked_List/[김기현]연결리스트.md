# 배열 Vs 연결 리스트

연결리스트는 배열과 같이 데이터 를 표현하는 자료구조중 하나! 

다만 배열과 연결리스트는 서로의 장단점을 보완하고 있기 때문에

연결리스트를 설명할 때 배열과 함께 묶어서 본다

배열의 특징으로는 index 를 이용하여 다음과 같이 한 메모리 공간 안에 데이터들이 나란히 저장되어 있음

<img width="592" alt="스크린샷 2023-08-23 오후 3 27 09" src="https://github.com/zzangzzangguy/CS-Study/assets/122965360/3ba25342-b8c0-40d6-a34c-fbdbc974ac2c">

ㄷ우리는 메모리에 저장할때 index를 통해 데이터에 접근할 수 있고 따라서 , 배열의 경우 index 만 알면 값에 대한 접근이 매우
빠르다는것이 배열의 장점

하지만 배열의 경우 마지막 index가 아닌 element를 삭제하거나 삽입할 경우 



https://github.com/zzangzzangguy/CS-Study/assets/122965360/433f6444-4146-4b7e-9232-bb86908dbac4

이와 같이 elmeetn 를 재배치하는 작업 탓에 오버헤드가 발생하는 단점이 있음

이를 보완한것이 연결리스트 

#연결리스트의 특징
*배열의 단점을 보완한 것 
*따라서 배열과 같이 순차적으로 데이터를 보관하는것이 아닌
*각각 떨어진 공간에 존재하는 데이터를 연결 해놓은것

<img width="794" alt="스크린샷 2023-08-23 오후 3 39 52" src="https://github.com/zzangzzangguy/CS-Study/assets/122965360/bb6a58ef-7fe5-412b-b2ed-8c98f39bc91c">

따라서, 원하는 때에 메모리에 공간을 할당해서 쓰고 배열처럼 중간 element를 삽입, 삭제시 재배치에 발생하는 오버헤드도 발생하지않음





배열처럼 index로 바로 접근하는것이 아니라
데이터에 접근시 첫 번째 데이터 부터 원하는 데이터까지 (단방향 연결 리스트)
순차적으로 찿아가야해서 접근속도가 느림


https://github.com/zzangzzangguy/CS-Study/assets/122965360/79b91775-b035-4a21-ad44-749ff9d58bf6


만약 데이터가 10000개 이상이면 10000번째 데이터에 접근시 -> 10000번 순회 

또한 내 다음 데이터에 대한 연결 정보를 저장하는 별도의 데이터 공간이 필요 
저장 공간의 효율이 높지 않음 
<img width="728" alt="스크린샷 2023-08-23 오후 3 43 45" src="https://github.com/zzangzzangguy/CS-Study/assets/122965360/f5c387b2-4c6f-4bfb-bc42-9cf45537ca88">

# 단방향 연결 리스트

앞서 설명했듯 연결리스트는 연속되지 않은 메모리에 저장된 데이터들을 연결시켜 놓은것

어떻게 연결을 하냐 -> 내다음 순서 데이터의 주소값을 내가 가지고 있어야 한다

따라서 단방향 연결리스트의 경우 데이터 모양은
<img width="256" alt="data" src="https://github.com/zzangzzangguy/CS-Study/assets/122965360/3bad8fe6-a9dc-4145-8615-794353b46c80">

data 는 내 데이터를 저장하는 것이고
next는 내 다음 데이터의 주소값을 저장하는 것 


위와 같은 모양을 두고 노드 (Node) 라고 함 

# 노드 생성

    class Node<T> {
        var data: T?
        var next: Node?

        init(data: T?, next: Node? = nil) {
            self.data = data
            self.next = next
        }
    } // 데이터의 타입은 국한되지않게 [제네릭](https://babbab2.tistory.com/136)으로 선언 

이제 데이터를 저장하고 싶을 때마다 배열의 element 가 아닌
이 Node를 생성해서 연결해주면 된다 

하지만 노드를 매번 생성 이전 노드와 연결해주는 것을 일일이 매번 작성할수 없으니
Node를 관리해주는 LinkedList 라는 클래스를 만들어 

    class LinkedList<T> {
    }

이후 연결리스트에 필요한 기능들을 추가!

# head 가장 첫 노드를 가리키는 프로퍼티

먼저 LinkedList에 head 라는 프로퍼티를 추가해줄 것 
 연결 리스트는 앞서 말했듯 데이터들이 기차처럼  연결 되어있는 구조 
 특정 데이터에 접근하려 할시
 


https://github.com/zzangzzangguy/CS-Study/assets/122965360/63d2f2ad-d13f-4fe8-b371-4019f8af03da

위와 같이 첫번째 노드부터 순자적으로 접근해야함 
때문에 연결 리스트에서는 첫 번째 노드를 항상 가지고 있어야 하고 이를 head 로 가리키는 것
위 예제의 경우 첫번째에 있는 3이란 data를 갖고 있는 노드가 head가 되는 것 

    class LinkedList<T> {
        private var head: Node<T>?
    }

따라서 첫 번째 노드를 가리킬 head 프로퍼티를 위와 같이 추가해주어야 한다 

# append(data:) 연결 리스트 맨 마지막에 노드 추가하기


https://github.com/zzangzzangguy/CS-Study/assets/122965360/a011605e-775f-4457-a887-3a538c81faf8

배열과 빗대어 생각하자면
append의 경우 연결리스트의 가장 마지막 노드를 찾아내어 그 뒤에 추가해주면 되는데 
노드의 가장 마지막을 찾아내는 방법은 head 노드부터 순회하며
node.next가 nil인 경우를 찿으면 된다

    func append(data: T?) {

        if head == nil {
            head = Node(data: data)
            return
        }

        var node = head
        while node?.next != nil {
            node = node?.next
        }
        node?.next = Node(data: data)
    }


<br>

