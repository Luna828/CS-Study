# ALU 구성 요소 

![image](https://github.com/hdaisywd/hdaisywd/assets/102342953/853cd662-aa23-4c66-a5d2-0b6d53b579cf)

- 산설연산장치: 산술 연산(+, -, *, %)를 수행한다. 
- 논리연산장치: 논리 연산(AND, OR, XOR, NOT)을 수행한다. 
- 시프트 레지스터: 비트들을 좌측 혹은 우측으로 이동시킨다.
- 보수기: 데이터에 대해 2의 보수를 취한다(음수화 한다).
- 상태 레지스터: 연산 결과의 상태를 나타내는 플래그들을 저장하는 레지스터이다. 

# 부호 비트 2진수 표현 

2진수 체계에서 정수는 0과 1, 부호 그리고 소수점으로 표현한다. 그리고 양수와 음수 모두를 표현해야 하기 떄문에 부호비트를 사용한다. 부호비트가 0이면 양수, 1이면 음수이다. 부호 비트를 사용하는 2진수 표현으로는 세가지 방법이 있다. 

**1. 1의 보수 표현** <br>
모든 비트를 반전하는 것이 1의 보수표현이다. 

**2. 2의 보수 표현** <br>
모든 비트들을 반전하고, 그 결과값에 1을 더하는 것이 2의 보수표현이다. 

||1의 보수|2의 부수|
|+9|0 0001001|0 0001001|
|-9|1 1110110|1 1110111|

1의 보수가 반환하는 과정이 훨씬 간단하지만, 일반적으로 컴퓨터들은 2의 보수 체계를 선택해서 사용한다. 2의 보수 경우에 같은 길이의 비트들로 포현할 수 있는 수의 개수가 하나 더 많기 때문이다. 

8비트를 예로 들어보자. -128은 2의보수로는 표현할 수 잇지만, 1의 보수로는 표현이 불가능하다. 부호비트를 남겨두고 표현을 하기 위해서 1의 보수는 한 자리가 더 필요한데에 비해 2의 보수는 부호 비트를 1로 두고 나머지 자리는 0으로 채워주면 되기 떄문이다. 따라서 대부분의 컴퓨터는 2의 보수를 사용한다. <br>

**💡 오버 플로우 (overflow)**

2의 보수들 간의 덧셈 결과 값이 포현 범위를 초과하는 경우에 발생하는 오류이다. 알고리즘은 풀다보면 흔하게 마주치는 문제인데, 8비트 숫자 포현에서 128이 그러한 오버플로우를 대표하는 숫자라고 할 수 있다. 128은 1111 1111 로 나타낼 수 있는데, 이는 부호비트의 자리를 남겨주지 않기 때문에 8비트 숫자체계로는 포현할 수 없는 숫자이다. 이처럼 숫자 표현 범위를 초과하여 연산의 결과를 도출할 경우 오버플로우 에러가 날 수 있다. 

# 논리 연산 

## 1. AND 연산

두 개의 데이터에서 같은 위치에 있는 비트들 간에 AND 연산을 수행하는 것이다. AND 연산은 두 수가 모두 1일때만 1이 된다. 

```
    1011 
    0001
=   0001
```

이 AND 연산은 마스크 연산을 할 때 사용한다. 마스크 연산은 데이터 내 특정 비트들의 값을 0으로 리셋시키기 위해 하는 동작이다. 예를 들면 이렇다. 

```
    1011
    0000
=   0000
```

각 자릿수에 대해 0을 AND 연산해주면 모든 자릿수가 0으로 바뀌게 된다. 

## 2. OR 연산

OR 연산은 각 위치의 비트 중 어느 하나만 1이라면 1을 반환해주는 연산이다. 선택적-세트 연산을 할 때 사용한다. 선택적-세트 연산이란 특정한 비트 자리의 수를 1로 만들어줄 때 사용한다. 

```
    10011001
    00100010
=   10111011
```

원하는 자릿수인 3번째, 7번째가 1로 바뀐 것을 확인할 수 있다. 

## 3. XOR 연산

이 연산은 exclusive-OR라고 불리는데, 서로 다른 값을 가지면 1을, 서로 같은 값을 가지면 0으로 만들어주는 연산을 한다. 이 연산은 선택적-보수 연산에 사용된다. 데이터 내의 특정 비트들의 값을 보수화 하기 위한 동작이다. 

```
    10010101
    00001111
=   10011010
```

위 연산은 상위 네 비트들은 원래의 값을 그대로 유지시켜주고 하위 네 비트들은 반전시켜준다. 

