# 연결 리스트(Linked List)

## 용어
연결리스트에서 알아야하는 주요 용어들입니다!

1. `노드`  : 데이터 요소 & 포인터로 구성 (각 노드는 데이터를 저장하거나 전달 역할)
2. `Head` : 리스트의 첫 번째 노드의 포인터 (시작점) 
3. `Tail` : 리스트의 마지막 노드의 포인터  (다음 노드를 가리키는 포인터 없음  -> 다음 포인터는 `null` or `비어있는 값`) 

## 개념 이해

연결리스트 = 흩어져 있는 데이터  <-> 배열,큐 = 일렬로 데이터 처리
연결 리스트는 CS에서 사용되는 데이터 구조이며, 배열처럼 데이터들을 `순차적으로 저장`하는 방법 중 하나다

배열은 접근 속도가 빠른 반면 중간 데이터의 삽입/삭제 시 오베헤드가 너무 크고, 저장공간 `확장/축소` 쉽지않다

즉, 배열의 단점을 보완하기 위해 나온 것

## 특징
- 각 노드에 저장된 다음 노드의 주소에 의해 연결됨
- 메모리가 연속될 주소일 필요가 없어 물리적인 순서를 맞추기 위한 오버헤드 ❌
- 원하는 만큼 노드를 동적으로 삽입, 삭제 ⭕️
- 메모리 공간에 정렬되어 있지 않고 흩어져 있기에 배열의 인덱스처럼 특정 노드에 접근하기 힘들다

## 종류

### 단일 연결리스트 (Single Linked List)
 
### 원형 연결리스트 (Double Linked List)

### 이중 연결리스트 (Circularly Linked List)


### 구현 

```swift
/*
 next가 다음 노드의 메모리 주소를 참조하려고 class로 만듬

*/
class Node<T> {
    var value: T
    var prev: Node?
    var next: Node?
    
    init(value: T) {
        self.value = value
        self.prev = nil
        self.next = nil
    }
}

class DoublyLinkedList<T> {
    var head: Node<T>?
    
    // 새 노드를 리스트의 끝에 추가하는 메서드
    func append(value: T) {
        let newNode = Node(value: value)
        if head == nil {
            head = newNode
        } else {
            var current = head
            while current?.next != nil {
                current = current?.next
            }
            current?.next = newNode
            newNode.prev = current
        }
    }
    
    // 이중 연결 리스트 순회하여 값 출력
    func printList() {
        var current = head
        while current != nil {
            print(current!.value, terminator: " <-> ")
            current = current?.next
        }
        print("nil")
    }
}

// 이중 연결 리스트 사용 예시
let doublyList = DoublyLinkedList<Int>()
doublyList.append(value: 1)
doublyList.append(value: 2)
doublyList.append(value: 3)
doublyList.printList() // 출력: 1 <-> 2 <-> 3 <-> nil

```

